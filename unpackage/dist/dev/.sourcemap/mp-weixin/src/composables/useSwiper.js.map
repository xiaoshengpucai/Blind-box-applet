{"version":3,"file":"useSwiper.js","sources":["src/composables/useSwiper.js"],"sourcesContent":["/**\r\n * 轮播图组合式函数\r\n * @description 提供轮播图的核心逻辑，支持自动播放、手势控制等\r\n */\r\nimport { ref, computed, nextTick, onMounted, onUnmounted } from 'vue';\r\n\r\n/**\r\n * 轮播图Hook\r\n * @param {Object} options - 配置选项\r\n * @returns {Object} 轮播图相关状态和方法\r\n */\r\nexport function useSwiper(options = {}) {\r\n  const {\r\n    slides = [],\r\n    autoplay = true,\r\n    interval = 3000,\r\n    duration = 500,\r\n    circular = true,\r\n    switchMode = 'slide'\r\n  } = options;\r\n\r\n  // ==================== 状态管理 ====================\r\n  const currentIndex = ref(circular ? 1 : 0);\r\n  const isTransitioning = ref(false);\r\n  const leavingIndex = ref(null);\r\n  const transitionStyle = ref(`transform ${duration}ms ease`);\r\n  \r\n  // 触摸相关状态\r\n  const touchStartX = ref(0);\r\n  const touchEndX = ref(0);\r\n  const touchCurrentX = ref(0);\r\n  const isDragging = ref(false);\r\n  const mouseDown = ref(false);\r\n  const dragOffset = ref(0);\r\n  const containerWidth = ref(0);\r\n  const isSeamlessJumping = ref(false);\r\n  \r\n  // 自动播放定时器\r\n  let autoplayTimer = null;\r\n\r\n  // ==================== 计算属性 ====================\r\n  /**\r\n   * 显示的轮播图列表（包含循环复制项）\r\n   */\r\n  const displaySlides = computed(() => {\r\n    const slideList = slides.value || [];\r\n    if (!slideList.length) return [];\r\n    \r\n    if (!circular) return slideList;\r\n    \r\n    // 为无缝轮播复制首尾项\r\n    return [\r\n      slideList[slideList.length - 1], // 复制最后一张\r\n      ...slideList,                    // 原始轮播图\r\n      slideList[0]                     // 复制第一张\r\n    ];\r\n  });\r\n\r\n  /**\r\n   * 当前真实索引（去除复制项的影响）\r\n   */\r\n  const realIndex = computed(() => {\r\n    if (!circular) return currentIndex.value;\r\n    \r\n    if (currentIndex.value === 0) return slides.value.length - 1;\r\n    if (currentIndex.value === displaySlides.value.length - 1) return 0;\r\n    return currentIndex.value - 1;\r\n  });\r\n\r\n  /**\r\n   * 动态transform值（包含拖拽偏移）\r\n   */\r\n  const dynamicTransform = computed(() => {\r\n    const baseOffset = currentIndex.value * 100;\r\n    // 在无缝跳转期间，不应用拖拽偏移\r\n    const dragPercentage = (isDragging.value && !isSeamlessJumping.value && containerWidth.value > 0) ? \r\n      (dragOffset.value / containerWidth.value) * 100 : 0;\r\n    return `translateX(-${baseOffset + dragPercentage}%)`;\r\n  });\r\n\r\n  /**\r\n   * 动态过渡样式\r\n   */\r\n  const dynamicTransition = computed(() => {\r\n    if (isDragging.value || isSeamlessJumping.value) {\r\n      return 'none';\r\n    }\r\n    return `transform ${duration}ms ease`;\r\n  });\r\n\r\n  // ==================== 核心方法 ====================\r\n  /**\r\n   * 切换到指定索引\r\n   * @param {number} index - 目标索引\r\n   * @param {boolean} withTransition - 是否使用过渡动画\r\n   */\r\n  const goToSlide = (index, withTransition = true) => {\r\n    if (isTransitioning.value && withTransition) return;\r\n    \r\n    transitionStyle.value = withTransition ? `transform ${duration}ms ease` : 'none';\r\n    currentIndex.value = index;\r\n    \r\n    if (withTransition) {\r\n      isTransitioning.value = true;\r\n      setTimeout(() => {\r\n        isTransitioning.value = false;\r\n      }, duration);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * 下一张\r\n   */\r\n  const next = () => {\r\n    if (isTransitioning.value) return;\r\n    \r\n    const nextIndex = currentIndex.value + 1;\r\n    console.log('Next切换:', {\r\n      currentIndex: currentIndex.value,\r\n      nextIndex,\r\n      totalSlides: displaySlides.value.length,\r\n      isLastSlide: nextIndex === displaySlides.value.length - 1,\r\n      circular\r\n    });\r\n    \r\n    goToSlide(nextIndex);\r\n    \r\n    if (circular && nextIndex === displaySlides.value.length - 1) {\r\n      console.log('执行无缝跳转: 从索引', nextIndex, '跳转到索引 1');\r\n      // 到达复制的第一张，等动画结束后跳到真实的第一张\r\n      setTimeout(() => {\r\n        isSeamlessJumping.value = true;\r\n        goToSlide(1, false);\r\n        console.log('无缝跳转完成，当前索引:', currentIndex.value);\r\n        // 立即重置无缝跳转状态\r\n        nextTick(() => {\r\n          isSeamlessJumping.value = false;\r\n        });\r\n      }, duration);\r\n      // 无缝跳转时不重置自动播放，保持连续性\r\n      return;\r\n    }\r\n    \r\n    resetAutoplay();\r\n  };\r\n\r\n  /**\r\n   * 上一张\r\n   */\r\n  const prev = () => {\r\n    if (isTransitioning.value) return;\r\n    \r\n    const prevIndex = currentIndex.value - 1;\r\n    goToSlide(prevIndex);\r\n    \r\n    if (circular && prevIndex === 0) {\r\n      // 到达复制的最后一张，等动画结束后跳到真实的最后一张\r\n      setTimeout(() => {\r\n        isSeamlessJumping.value = true;\r\n        goToSlide(slides.value.length, false);\r\n        // 立即重置无缝跳转状态\r\n        nextTick(() => {\r\n          isSeamlessJumping.value = false;\r\n        });\r\n      }, duration);\r\n      // 无缝跳转时不重置自动播放，保持连续性\r\n      return;\r\n    }\r\n    \r\n    resetAutoplay();\r\n  };\r\n\r\n  /**\r\n   * 跳转到指定真实索引\r\n   * @param {number} realIndex - 真实索引\r\n   */\r\n  const goToRealIndex = (realIndex) => {\r\n    const targetIndex = circular ? realIndex + 1 : realIndex;\r\n    goToSlide(targetIndex);\r\n    resetAutoplay();\r\n  };\r\n\r\n  // ==================== 自动播放控制 ====================\r\n  /**\r\n   * 开始自动播放\r\n   */\r\n  const startAutoplay = () => {\r\n    if (!autoplay || slides.value.length <= 1) return;\r\n    \r\n    stopAutoplay();\r\n    autoplayTimer = setInterval(() => {\r\n      next();\r\n    }, interval);\r\n  };\r\n\r\n  /**\r\n   * 停止自动播放\r\n   */\r\n  const stopAutoplay = () => {\r\n    if (autoplayTimer) {\r\n      clearInterval(autoplayTimer);\r\n      autoplayTimer = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * 重置自动播放\r\n   */\r\n  const resetAutoplay = () => {\r\n    if (!autoplay) return;\r\n    stopAutoplay();\r\n    startAutoplay();\r\n  };\r\n\r\n  // ==================== 触摸事件处理 ====================\r\n  const SWIPE_THRESHOLD = 50; // 滑动阈值\r\n\r\n  /**\r\n   * 触摸开始\r\n   */\r\n  const handleTouchStart = (e) => {\r\n    if (isTransitioning.value) return;\r\n    \r\n    const touch = e.touches ? e.touches[0] : e;\r\n    touchStartX.value = touch.clientX;\r\n    touchCurrentX.value = touch.clientX;\r\n    isDragging.value = true;\r\n    mouseDown.value = true;\r\n    dragOffset.value = 0;\r\n    \r\n    // 获取容器宽度（用于计算百分比）\r\n    const target = e.currentTarget;\r\n    if (target) {\r\n      containerWidth.value = target.offsetWidth || target.clientWidth || 375;\r\n    }\r\n    \r\n    stopAutoplay();\r\n  };\r\n\r\n  /**\r\n   * 触摸移动\r\n   */\r\n  const handleTouchMove = (e) => {\r\n    if (!isDragging.value && !mouseDown.value) return;\r\n    \r\n    const touch = e.touches ? e.touches[0] : e;\r\n    touchCurrentX.value = touch.clientX;\r\n    touchEndX.value = touch.clientX;\r\n\r\n    // 计算拖拽偏移量\r\n    dragOffset.value = -(touchCurrentX.value - touchStartX.value);\r\n    // 防止默认滚动行为\r\n    e.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * 触摸结束\r\n   */\r\n  const handleTouchEnd = () => {\r\n    if (!isDragging.value && !mouseDown.value) return;\r\n    \r\n    const touchDiff = touchEndX.value - touchStartX.value;\r\n    \r\n    if (Math.abs(touchDiff) > SWIPE_THRESHOLD) {\r\n      if (touchDiff > 0) {\r\n        prev(); // 向右滑动，显示上一张\r\n      } else {\r\n        next(); // 向左滑动，显示下一张\r\n      }\r\n    } else {\r\n      resetAutoplay(); // 滑动距离不够，重置自动播放\r\n    }\r\n    \r\n    // 在状态重置后再重置拖拽偏移\r\n    isDragging.value = false;\r\n    mouseDown.value = false;\r\n    \r\n    // 延迟重置拖拽偏移，确保动画完成\r\n    nextTick(() => {\r\n      dragOffset.value = 0;\r\n    });\r\n  };\r\n\r\n  // ==================== 生命周期 ====================\r\n  onMounted(() => {\r\n    startAutoplay();\r\n  });\r\n\r\n  onUnmounted(() => {\r\n    stopAutoplay();\r\n  });\r\n\r\n  // ==================== 返回API ====================\r\n  return {\r\n    // 状态\r\n    currentIndex,\r\n    realIndex,\r\n    displaySlides,\r\n    isTransitioning,\r\n    transitionStyle,\r\n    \r\n    // 动态样式\r\n    dynamicTransform,\r\n    dynamicTransition,\r\n    isDragging,\r\n    dragOffset,\r\n    \r\n    // 方法\r\n    next,\r\n    prev,\r\n    goToSlide,\r\n    goToRealIndex,\r\n    \r\n    // 自动播放控制\r\n    startAutoplay,\r\n    stopAutoplay,\r\n    resetAutoplay,\r\n    \r\n    // 触摸事件\r\n    handleTouchStart,\r\n    handleTouchMove,\r\n    handleTouchEnd\r\n  };\r\n}\r\n"],"names":["ref","computed","uni","nextTick","realIndex","onMounted","onUnmounted"],"mappings":"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"}