{"version":3,"file":"useSwiper.js","sources":["src/composables/useSwiper.js"],"sourcesContent":["/**\n * 轮播图组合式函数\n * @description 提供轮播图的核心逻辑，支持自动播放、手势控制等\n */\nimport { ref, computed, watch, toRefs,onMounted, onUnmounted, nextTick } from 'vue';\n\n/**\n * 轮播图Hook\n * @param {Object} options - 配置选项\n * @returns {Object} 轮播图相关状态和方法\n */\nexport function useSwiper(componentProps) {\n  // 使用 toRefs 确保所有 props 都是响应式的\n  // 将 componentProps.mode 别名为 switchMode\n  const {\n    slides,\n    autoplay,\n    interval,\n    duration,\n    circular,\n    mode: switchMode\n  } = toRefs(componentProps);\n\n  // ==================== 状态管理 ====================\n  const currentIndex = ref(circular.value && switchMode.value === 'slide' ? 1 : 0);\n  const isInitialized = ref(false);\n  const isTransitioning = ref(false);\n  const transitionStyle = ref(`transform ${duration.value}ms ease`);\n  \n  // Fade 模式专用状态\n  const fadeLeavingIndex = ref(null);\n  const fadeEnteringIndex = ref(null);\n  \n\n  // 触摸相关状态\n  const touchStartX = ref(0);\n  const touchEndX = ref(0);\n  const touchCurrentX = ref(0);\n  const isDragging = ref(false);\n  const mouseDown = ref(false);\n  const dragOffset = ref(0);\n  const containerWidth = ref(0);\n  const isSeamlessJumping = ref(false);\n  \n  // 自动播放定时器\n  let autoplayTimer = null;\n  let seamlessJumpTimer = null;\n\n  // ==================== 计算属性 ====================\n  /**\n   * 显示的轮播图列表（包含循环复制项）\n   */\n  const displaySlides = computed(() => {\n    const slideList = slides.value || [];\n    if (!slideList.length) return [];\n    \n    // 仅在 slide 模式下且需要循环时，才复制首尾项\n    if (switchMode.value !== 'slide' || !circular.value) {\n      return slideList;\n    }\n    \n    // 为无缝轮播复制首尾项\n    return [\n      slideList[slideList.length - 1], // 复制最后一张\n      ...slideList,                    // 原始轮播图\n      slideList[0]                     // 复制第一张\n    ];\n  });\n\n  /**\n   * 当前真实索引（去除复制项的影响）\n   */\n  const realIndex = computed(() => {\n    if (switchMode.value === 'fade') {\n      return currentIndex.value;\n    }\n\n    if (!circular.value) {\n      return currentIndex.value;\n    }\n    \n    const slideCount = slides.value.length;\n    if (slideCount === 0) return 0;\n\n    if (currentIndex.value === 0) {\n      return slideCount - 1;\n    }\n    if (currentIndex.value === displaySlides.value.length - 1) {\n      return 0;\n    }\n    return currentIndex.value - 1;\n  });\n\n  /**\n   * 动态transform值（包含拖拽偏移）\n   */\n  const dynamicTransform = computed(() => {\n    const baseOffset = currentIndex.value * 100;\n    // 在无缝跳转期间，不应用拖拽偏移\n    const dragPercentage = (isDragging.value && !isSeamlessJumping.value && containerWidth.value > 0) ? \n      (dragOffset.value / containerWidth.value) * 100 : 0;\n    \n    const transformValue = `translateX(-${baseOffset + dragPercentage}%)`;\n\n    return transformValue;\n  });\n\n  /**\n   * 动态过渡样式\n   */\n  const dynamicTransition = computed(() => {\n    // 无缝跳转或拖拽时不使用过渡动画\n    if (isDragging.value || isSeamlessJumping.value) {\n      return 'none';\n    }\n    \n    // 使用transitionStyle的值，这样可以控制无缝跳转时的动画\n    return transitionStyle.value;\n  });\n\n  // ==================== 核心方法 ====================\n  /**\n   * 跳转到指定幻灯片\n   * @param {number} index - 目标索引\n   * @param {boolean} withTransition - 是否使用过渡动画\n   */\n  const goToSlide = (index, withTransition = true) => {\n    if (isTransitioning.value && withTransition) {\n      return;\n    }\n    \n    // 对于 fade 模式，直接使用传入的索引\n    if (switchMode.value === 'fade') {\n      // Fade 模式下的过渡状态管理\n      if (withTransition) {\n        fadeLeavingIndex.value = realIndex.value;\n        fadeEnteringIndex.value = index;\n      }\n      \n      // 直接设置真实索引\n      currentIndex.value = index;\n       \n      if (withTransition) {\n        isTransitioning.value = true;\n        \n        // fade 模式的动画时长是 1s，所以等待 1.2s 确保动画完成\n        setTimeout(() => {\n          fadeLeavingIndex.value = null;\n          fadeEnteringIndex.value = null;\n          isTransitioning.value = false;\n        }, 1200);\n      }\n      return;\n    }\n    \n    // 对于 slide 模式，使用原有的逻辑\n    // 限制索引范围\n    const minIndex = 0;\n    // 使用 displaySlides 的长度来确定最大索引\n    const maxIndex = displaySlides.value.length - 1;\n    const clampedIndex = Math.max(minIndex, Math.min(index, maxIndex));\n    \n    transitionStyle.value = withTransition ? `transform ${duration.value}ms ease` : 'none';\n    currentIndex.value = clampedIndex;\n    \n    if (withTransition && duration.value > 0) {\n      isTransitioning.value = true;\n      \n      // 确保只在过渡结束后重置状态\n      setTimeout(() => {\n        isTransitioning.value = false;\n      }, duration.value);\n      \n      // 额外的安全检查：如果duration太长，设置一个最大超时\n      setTimeout(() => {\n        if (isTransitioning.value) {\n          isTransitioning.value = false;\n        }\n      }, Math.max(duration.value + 100, 1000)); // 最大1秒\n    } else {\n      // 如果没有过渡动画或duration为0，立即重置状态\n      isTransitioning.value = false;\n    }\n  };\n\n  /**\n   * 清理定时器\n   */\n  const clearSeamlessTimer = () => {\n    if (seamlessJumpTimer) {\n      clearTimeout(seamlessJumpTimer);\n      seamlessJumpTimer = null;\n    }\n  };\n  \n  /**\n   * 强制重置过渡状态\n   */\n  const resetTransitionState = () => {\n    isTransitioning.value = false;\n    isSeamlessJumping.value = false;\n    // 清除 fade 模式的过渡状态\n    fadeLeavingIndex.value = null;\n    fadeEnteringIndex.value = null;\n  };\n\n  /**\n   * 下一张\n   */\n  const next = () => {\n    if (isTransitioning.value) {\n      return;\n    }\n    \n    if (!slides.value || slides.value.length === 0) {\n      return;\n    }\n    \n    // 对于 fade 模式，直接操作 slides 数组\n    if (switchMode.value === 'fade') {\n      const nextRealIndex = (realIndex.value + 1) % slides.value.length;\n      goToRealIndex(nextRealIndex);\n      return;\n    }\n    \n    const nextIndex = currentIndex.value + 1;\n\n    \n    // 检查是否需要无缝跳转\n    if (circular.value && nextIndex === displaySlides.value.length - 1) {\n   \n      // 先执行正常的切换动画\n      goToSlide(nextIndex);\n      \n      // 动画完成后执行无缝跳转\n      setTimeout(() => {\n        isSeamlessJumping.value = true;\n        goToSlide(1, false); // 无动画跳转到真实的第一张\n  \n        // 等待DOM更新后恢复动画\n        nextTick(() => {\n          isSeamlessJumping.value = false;\n        });\n      }, duration.value);\n    } else {\n      // 正常切换\n      goToSlide(nextIndex);\n    }\n    \n    resetAutoplay();\n  };\n\n  /**\n   * 上一张\n   */\n  const prev = () => {\n    if (isTransitioning.value) {\n      return;\n    }\n    \n    if (!slides.value || slides.value.length === 0) {\n      return;\n    }\n    \n    // 对于 fade 模式，直接操作 slides 数组\n    if (switchMode.value === 'fade') {\n      const prevRealIndex = (realIndex.value - 1 + slides.value.length) % slides.value.length;\n      goToRealIndex(prevRealIndex);\n      return;\n    }\n    \n    const prevIndex = currentIndex.value - 1;\n\n    \n    // 检查是否需要无缝跳转\n    if (circular.value && prevIndex === 0) {\n \n      // 先执行正常的切换动画\n      goToSlide(prevIndex);\n      \n      // 动画完成后执行无缝跳转\n      setTimeout(() => {\n        isSeamlessJumping.value = true;\n        goToSlide(displaySlides.value.length - 2, false); // 无动画跳转到真实的最后一张\n     \n        // 等待DOM更新后恢复动画\n        nextTick(() => {\n          isSeamlessJumping.value = false;\n        });\n      }, duration.value);\n    } else {\n      // 正常切换\n      goToSlide(prevIndex);\n    }\n    \n    resetAutoplay();\n  };\n\n  /**\n   * 跳转到指定真实索引\n   * @param {number} realIndex - 真实索引\n   */\n  const goToRealIndex = (realIndex) => {\n    if (isTransitioning.value || isSeamlessJumping.value) {\n      resetTransitionState();\n      // 重新检查状态\n      if (isTransitioning.value || isSeamlessJumping.value) {\n        return;\n      }\n    }\n    \n    // 清除之前的无缝跳转定时器\n    clearSeamlessTimer();\n    \n    // 对于 fade 模式，直接使用真实索引\n    if (switchMode.value === 'fade') {\n      goToSlide(realIndex);\n    } else {\n      // 对于 slide 模式，需要处理循环复制项\n      const targetIndex = circular.value ? realIndex + 1 : realIndex;\n      goToSlide(targetIndex);\n    }\n    \n    resetAutoplay();\n  };\n\n  // ==================== 自动播放控制 ====================\n  /**\n   * 开始自动播放\n   */\n  const startAutoplay = () => {\n    if (!autoplay.value || slides.value.length <= 1) return;\n    \n    stopAutoplay();\n    autoplayTimer = setInterval(() => {\n      next();\n    }, interval.value);\n  };\n\n  /**\n   * 停止自动播放\n   */\n  const stopAutoplay = () => {\n    if (autoplayTimer) {\n      clearInterval(autoplayTimer);\n      autoplayTimer = null;\n    }\n    // 同时清理无缝跳转定时器\n    clearSeamlessTimer();\n  };\n\n  /**\n   * 重置自动播放\n   */\n  const resetAutoplay = () => {\n    if (!autoplay.value) return;\n    stopAutoplay();\n    startAutoplay();\n  };\n\n  // ==================== 触摸事件处理 ====================\n  const SWIPE_THRESHOLD = 50; // 滑动阈值\n\n  /**\n   * 触摸开始\n   */\n  const handleTouchStart = (e) => {\n    if (!e || isTransitioning.value || isSeamlessJumping.value) {\n      return;\n    }\n    \n    const touch = e.touches ? e.touches[0] : e;\n    touchStartX.value = touch.clientX;\n    touchCurrentX.value = touch.clientX;\n    isDragging.value = true;\n    mouseDown.value = true;\n    dragOffset.value = 0;\n    \n    // 获取容器宽度（用于计算百分比）\n    const target = e.currentTarget;\n    if (target) {\n      containerWidth.value = target.offsetWidth || target.clientWidth || 375;\n    }\n    \n    stopAutoplay();\n  };\n\n  /**\n   * 触摸移动\n   */\n  const handleTouchMove = (e) => {\n    if (!e || (!isDragging.value && !mouseDown.value)) {\n      return;\n    }\n    \n    if (isSeamlessJumping.value) {\n      return; // 无缝跳转时不处理触摸移动\n    }\n    \n    const touch = e.touches ? e.touches[0] : e;\n    touchCurrentX.value = touch.clientX;\n    touchEndX.value = touch.clientX;\n    \n    // 计算拖拽偏移量\n    dragOffset.value = -(touchCurrentX.value - touchStartX.value);\n    \n    // 防止默认滚动行为\n    if (e && typeof e.preventDefault === 'function') {\n      e.preventDefault();\n    }\n  };\n\n    /**\n   * 触摸结束\n   */\n  const handleTouchEnd = () => {\n    // 如果没有拖拽或鼠标按下，说明只是点击，不处理\n    if (!isDragging.value && !mouseDown.value) {\n      return;\n    }\n\n    // 只要dragOffset在[-100, 100]区间内，认为只是点击，不执行任何操作\n    if (Math.abs(dragOffset.value) <= 150) {\n      isDragging.value = false;\n      mouseDown.value = false;\n      dragOffset.value = 0;\n      return;\n    }\n\n    // 如果状态被阻塞，强制重置\n    if (isTransitioning.value) {\n     resetTransitionState();\n    }\n    \n    const touchDiff = touchEndX.value - touchStartX.value;\n    \n    // 检查是否有足够的滑动距离\n    if (Math.abs(touchDiff) > SWIPE_THRESHOLD) {\n      if (touchDiff > 0) {\n        prev(); // 向右滑动，显示上一张\n      } else {\n        next(); // 向左滑动，显示下一张\n      }\n    } else {\n      resetAutoplay(); // 滑动距离不够，重置自动播放\n    }\n\n    // 重置拖拽状态\n    isDragging.value = false;\n    mouseDown.value = false;\n\n    // 延迟重置拖拽偏移，确保动画完成\n    nextTick(() => {\n      dragOffset.value = 0;\n    });\n  };\n\n  // ==================== 初始化方法 ====================\n  /**\n   * 初始化轮播图\n   */\n  const initializeSwiper = () => {\n    if (isInitialized.value) return;\n    \n   \n    // 确保初始状态正确\n    isTransitioning.value = false;\n    isSeamlessJumping.value = false;\n    \n    // 确保初始索引正确\n    if (circular.value && slides.value && slides.value.length > 0) {\n      currentIndex.value = 1; // 循环模式下从复制的第一张开始\n    } else {\n      currentIndex.value = 0; // 非循环模式下从第一张开始\n    }\n    \n    isInitialized.value = true;\n  };\n\n  // ==================== 生命周期 ====================\n  onMounted(() => {\n    initializeSwiper();\n    startAutoplay();\n  });\n\n  // 监听slides变化，重新初始化\n  watch(() => slides.value, (newSlides) => {\n    if (newSlides && newSlides.length > 0) {\n      isInitialized.value = false;\n      initializeSwiper();\n    }\n  }, { immediate: true });\n\n  onUnmounted(() => {\n    stopAutoplay();\n    clearSeamlessTimer();\n  });\n\n  // ==================== 返回API ====================\n  return {\n    // 状态\n    currentIndex,\n    realIndex,\n    displaySlides,\n    isTransitioning,\n    transitionStyle,\n    \n    // Fade 模式过渡状态\n    fadeLeavingIndex,\n    fadeEnteringIndex,\n    \n    // 动态样式\n    dynamicTransform,\n    dynamicTransition,\n    isDragging,\n    dragOffset,\n    \n    // 方法\n    next,\n    prev,\n    goToSlide,\n    goToRealIndex,\n    resetTransitionState,\n    \n    // 自动播放控制\n    startAutoplay,\n    stopAutoplay,\n    resetAutoplay,\n    \n    // 触摸事件\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  };\n}\n"],"names":["toRefs","ref","computed","nextTick","realIndex","onMounted","watch","onUnmounted"],"mappings":"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"}