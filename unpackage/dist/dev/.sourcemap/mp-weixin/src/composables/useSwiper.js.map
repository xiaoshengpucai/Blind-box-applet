{"version":3,"file":"useSwiper.js","sources":["src/composables/useSwiper.js"],"sourcesContent":["/**\n * 轮播图组合式函数\n * @description 提供轮播图的核心逻辑，支持自动播放、手势控制等\n */\nimport { ref, computed, nextTick,watch, onMounted, onUnmounted } from 'vue';\n\n/**\n * 轮播图Hook\n * @param {Object} options - 配置选项\n * @returns {Object} 轮播图相关状态和方法\n */\nexport function useSwiper(options = {}) {\n  const {\n    slides = [],\n    autoplay = true,\n    interval = 3000,\n    duration = 500,\n    circular = true,\n    switchMode = 'slide'\n  } = options;\n\n  // ==================== 状态管理 ====================\n  const currentIndex = ref(circular ? 1 : 0);\n  const isInitialized = ref(false);\n  const isTransitioning = ref(false);\n  const leavingIndex = ref(null);\n  const transitionStyle = ref(`transform ${duration}ms ease`);\n  \n\n\n  // 触摸相关状态\n  const touchStartX = ref(0);\n  const touchEndX = ref(0);\n  const touchCurrentX = ref(0);\n  const isDragging = ref(false);\n  const mouseDown = ref(false);\n  const dragOffset = ref(0);\n  const containerWidth = ref(0);\n  const isSeamlessJumping = ref(false);\n  \n  // 自动播放定时器\n  let autoplayTimer = null;\n  let seamlessJumpTimer = null;\n\n  // ==================== 计算属性 ====================\n  /**\n   * 显示的轮播图列表（包含循环复制项）\n   */\n  const displaySlides = computed(() => {\n    const slideList = slides.value || [];\n    if (!slideList.length) return [];\n    \n    if (!circular) return slideList;\n    \n    // 为无缝轮播复制首尾项\n    const displayList = [\n      slideList[slideList.length - 1], // 复制最后一张\n      ...slideList,                    // 原始轮播图\n      slideList[0]                     // 复制第一张\n    ];\n    \n    return displayList;\n  });\n\n  /**\n   * 当前真实索引（去除复制项的影响）\n   */\n  const realIndex = computed(() => {\n    if (!circular) return currentIndex.value;\n    \n    // 处理边界情况\n    if (currentIndex.value === 0) return slides.value.length - 1;\n    if (currentIndex.value === displaySlides.value.length - 1) return 0;\n    \n    // 正常情况：减去复制项的影响\n    const realIdx = currentIndex.value - 1;\n    return realIdx;\n  });\n\n  /**\n   * 动态transform值（包含拖拽偏移）\n   */\n  const dynamicTransform = computed(() => {\n    const baseOffset = currentIndex.value * 100;\n    // 在无缝跳转期间，不应用拖拽偏移\n    const dragPercentage = (isDragging.value && !isSeamlessJumping.value && containerWidth.value > 0) ? \n      (dragOffset.value / containerWidth.value) * 100 : 0;\n    \n    const transformValue = `translateX(-${baseOffset + dragPercentage}%)`;\n\n    return transformValue;\n  });\n\n  /**\n   * 动态过渡样式\n   */\n  const dynamicTransition = computed(() => {\n    // 无缝跳转或拖拽时不使用过渡动画\n    if (isDragging.value || isSeamlessJumping.value) {\n      return 'none';\n    }\n    \n    // 使用transitionStyle的值，这样可以控制无缝跳转时的动画\n    return transitionStyle.value;\n  });\n\n  // ==================== 核心方法 ====================\n    /**\n   * 切换到指定索引\n   * @param {number} index - 目标索引\n   * @param {boolean} withTransition - 是否使用过渡动画\n   */\n  const goToSlide = (index, withTransition = true) => {\n    if (isTransitioning.value && withTransition) {\n      return;\n    }\n    \n    // 限制索引范围\n    const minIndex = 0;\n    const maxIndex = displaySlides.value.length - 1;\n    const clampedIndex = Math.max(minIndex, Math.min(index, maxIndex));\n    \n    transitionStyle.value = withTransition ? `transform ${duration}ms ease` : 'none';\n    currentIndex.value = clampedIndex;\n    \n    if (withTransition && duration > 0) {\n      isTransitioning.value = true;\n      // 确保只在过渡结束后重置状态\n      setTimeout(() => {\n        isTransitioning.value = false;\n      }, duration);\n      \n      // 额外的安全检查：如果duration太长，设置一个最大超时\n      setTimeout(() => {\n        if (isTransitioning.value) {\n          isTransitioning.value = false;\n        }\n      }, Math.max(duration + 100, 1000)); // 最大1秒\n    } else {\n      // 如果没有过渡动画或duration为0，立即重置状态\n      isTransitioning.value = false;\n    }\n  };\n\n  /**\n   * 清理定时器\n   */\n  const clearSeamlessTimer = () => {\n    if (seamlessJumpTimer) {\n      clearTimeout(seamlessJumpTimer);\n      seamlessJumpTimer = null;\n    }\n  };\n  /**\n   * 强制重置过渡状态\n   */\n  const resetTransitionState = () => {\n    isTransitioning.value = false;\n    isSeamlessJumping.value = false;\n  };\n\n  /**\n   * 下一张\n   */\n  const next = () => {\n    if (isTransitioning.value) {\n      return;\n    }\n    \n    if (!slides.value || slides.value.length === 0) {\n      return;\n    }\n    \n    const nextIndex = currentIndex.value + 1;\n\n    \n    // 检查是否需要无缝跳转\n    if (circular && nextIndex === displaySlides.value.length - 1) {\n   \n      // 先执行正常的切换动画\n      goToSlide(nextIndex);\n      \n      // 动画完成后执行无缝跳转\n      setTimeout(() => {\n        isSeamlessJumping.value = true;\n        goToSlide(1, false); // 无动画跳转到真实的第一张\n  \n        // 等待DOM更新后恢复动画\n        nextTick(() => {\n          isSeamlessJumping.value = false;\n        });\n      }, duration);\n    } else {\n      // 正常切换\n      goToSlide(nextIndex);\n    }\n    \n    resetAutoplay();\n  };\n\n  /**\n   * 上一张\n   */\n  const prev = () => {\n    if (isTransitioning.value) {\n      return;\n    }\n    \n    if (!slides.value || slides.value.length === 0) {\n      return;\n    }\n    \n    const prevIndex = currentIndex.value - 1;\n\n    \n    // 检查是否需要无缝跳转\n    if (circular && prevIndex === 0) {\n \n      // 先执行正常的切换动画\n      goToSlide(prevIndex);\n      \n      // 动画完成后执行无缝跳转\n      setTimeout(() => {\n        isSeamlessJumping.value = true;\n        goToSlide(displaySlides.value.length - 2, false); // 无动画跳转到真实的最后一张\n     \n        // 等待DOM更新后恢复动画\n        nextTick(() => {\n          isSeamlessJumping.value = false;\n        });\n      }, duration);\n    } else {\n      // 正常切换\n      goToSlide(prevIndex);\n    }\n    \n    resetAutoplay();\n  };\n\n  /**\n   * 跳转到指定真实索引\n   * @param {number} realIndex - 真实索引\n   */\n  const goToRealIndex = (realIndex) => {\n    if (isTransitioning.value || isSeamlessJumping.value) {\n      resetTransitionState();\n      // 重新检查状态\n      if (isTransitioning.value || isSeamlessJumping.value) {\n        return;\n      }\n    }\n    \n    // 清除之前的无缝跳转定时器\n    clearSeamlessTimer();\n    \n    const targetIndex = circular ? realIndex + 1 : realIndex;\n    \n    // 直接调用goToSlide，不使用startTransition\n    goToSlide(targetIndex);\n    resetAutoplay();\n  };\n\n  // ==================== 自动播放控制 ====================\n  /**\n   * 开始自动播放\n   */\n  const startAutoplay = () => {\n    if (!autoplay || slides.value.length <= 1) return;\n    \n    stopAutoplay();\n    autoplayTimer = setInterval(() => {\n      next();\n    }, interval);\n  };\n\n  /**\n   * 停止自动播放\n   */\n  const stopAutoplay = () => {\n    if (autoplayTimer) {\n      clearInterval(autoplayTimer);\n      autoplayTimer = null;\n    }\n    // 同时清理无缝跳转定时器\n    clearSeamlessTimer();\n  };\n\n  /**\n   * 重置自动播放\n   */\n  const resetAutoplay = () => {\n    if (!autoplay) return;\n    stopAutoplay();\n    startAutoplay();\n  };\n\n  // ==================== 触摸事件处理 ====================\n  const SWIPE_THRESHOLD = 50; // 滑动阈值\n\n  /**\n   * 触摸开始\n   */\n  const handleTouchStart = (e) => {\n    if (isTransitioning.value || isSeamlessJumping.value) {\n      return;\n    }\n    \n    const touch = e.touches ? e.touches[0] : e;\n    touchStartX.value = touch.clientX;\n    touchCurrentX.value = touch.clientX;\n    isDragging.value = true;\n    mouseDown.value = true;\n    dragOffset.value = 0;\n    \n    // 获取容器宽度（用于计算百分比）\n    const target = e.currentTarget;\n    if (target) {\n      containerWidth.value = target.offsetWidth || target.clientWidth || 375;\n    }\n    \n    stopAutoplay();\n  };\n\n  /**\n   * 触摸移动\n   */\n  const handleTouchMove = (e) => {\n    if (!isDragging.value && !mouseDown.value) {\n      return;\n    }\n    \n    if (isSeamlessJumping.value) {\n      return; // 无缝跳转时不处理触摸移动\n    }\n    \n    const touch = e.touches ? e.touches[0] : e;\n    touchCurrentX.value = touch.clientX;\n    touchEndX.value = touch.clientX;\n    \n    // 计算拖拽偏移量\n    dragOffset.value = -(touchCurrentX.value - touchStartX.value);\n    \n    // 防止默认滚动行为\n    e.preventDefault();\n  };\n\n    /**\n   * 触摸结束\n   */\n  const handleTouchEnd = () => {\n   // 如果没有拖拽或鼠标按下，说明只是点击，不处理\n    if (!isDragging.value || !mouseDown.value) {\n      return;\n    }\n\n    // 只要dragOffset在[-100, 100]区间内，认为只是点击，不执行任何操作\n    if (Math.abs(dragOffset.value) <= 150) {\n      isDragging.value = false;\n      mouseDown.value = false;\n      dragOffset.value = 0;\n      return;\n    }\n\n    // 如果状态被阻塞，强制重置\n    if (isTransitioning.value) {\n     resetTransitionState();\n    }\n    \n    const touchDiff = touchEndX.value - touchStartX.value;\n    \n    // 检查是否有足够的滑动距离\n    if (Math.abs(touchDiff) > SWIPE_THRESHOLD) {\n      if (touchDiff > 0) {\n        prev(); // 向右滑动，显示上一张\n      } else {\n        next(); // 向左滑动，显示下一张\n      }\n    } else {\n      resetAutoplay(); // 滑动距离不够，重置自动播放\n    }\n\n    // 重置拖拽状态\n    isDragging.value = false;\n    mouseDown.value = false;\n\n    // 延迟重置拖拽偏移，确保动画完成\n    nextTick(() => {\n      dragOffset.value = 0;\n    });\n  };\n\n  // ==================== 初始化方法 ====================\n  /**\n   * 初始化轮播图\n   */\n  const initializeSwiper = () => {\n    if (isInitialized.value) return;\n    \n   \n    // 确保初始状态正确\n    isTransitioning.value = false;\n    isSeamlessJumping.value = false;\n    \n    // 确保初始索引正确\n    if (circular && slides.value && slides.value.length > 0) {\n      currentIndex.value = 1; // 循环模式下从复制的第一张开始\n    } else {\n      currentIndex.value = 0; // 非循环模式下从第一张开始\n    }\n    \n    isInitialized.value = true;\n  };\n\n  // ==================== 生命周期 ====================\n  onMounted(() => {\n    initializeSwiper();\n    startAutoplay();\n  });\n\n  // 监听slides变化，重新初始化\n  watch(() => slides.value, (newSlides) => {\n    if (newSlides && newSlides.length > 0) {\n      isInitialized.value = false;\n      initializeSwiper();\n    }\n  }, { immediate: true });\n\n  onUnmounted(() => {\n    stopAutoplay();\n    clearSeamlessTimer();\n  });\n\n  // ==================== 返回API ====================\n  return {\n    // 状态\n    currentIndex,\n    realIndex,\n    displaySlides,\n    isTransitioning,\n    transitionStyle,\n    \n    // 动态样式\n    dynamicTransform,\n    dynamicTransition,\n    isDragging,\n    dragOffset,\n    \n    // 方法\n    next,\n    prev,\n    goToSlide,\n    goToRealIndex,\n    resetTransitionState,\n    \n    // 自动播放控制\n    startAutoplay,\n    stopAutoplay,\n    resetAutoplay,\n    \n    // 触摸事件\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  };\n}\n"],"names":["ref","computed","nextTick","realIndex","onMounted","watch","onUnmounted"],"mappings":"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"}